---
title: "Exercises 4"
author: "Caitlin Winkler"
date: "12/11/2017"
output:
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r files}

library(valr)
library(eda)
library(tidyverse)
library(ggplot2)
library(cowplot)

# genes_bed 
genes_file <- system.file("extdata", "hg19_genes.bed.gz", package = "eda")
genes <- read_bed(genes_file, n_fields = 6)

# chipseq_bedgraph
bed <- read_bed(valr_example("hela.h3k4.chip.bg.gz"),
                n_fields = 4)
bg <- select(bed, everything(), value = name)
bg <- mutate(bg, 
              value = as.numeric(value))

# genome_bed 
genome_file <- system.file("extdata", "hg19_genome.txt.gz", package = "eda")
genome <- read_genome(genome_file)

```


# Overview

Here is a [link](https://raw.githubusercontent.com/rnabioco/eda/master/vignettes/exercises-4.Rmd) to the text of these exercises.

# Question 1

What is the difference between `bed_shuffle()` and `bed_random()`? Explain your answer. No code is necessary, but you are welcome to show some example usage if it helps your explanation. 

## Interpretation

Both the `bed_shuffle()` and the `bed_random()` functions create new random intervals or permutations of existing intervals. `bed_random()`requires a genome file (which includes the name and size of chromosomes). From this, `bed_random()` generates a set of random intervals spread across the genome, which are set by defining the `length` and number (`n`) of intervals. By comparison, `bed_shuffle()` shuffles the location of a set of predefined intervals, while maintaining the length of each interval.

The following is an example from class illustrating the `bed_random()` and `bed_shuffle()` functions:

```{r q1}

#Use `bed_random()` to generate 100,000 random intervals of 100 bp each, with a seed of 42
#chr1 has the most intervals (7991)

bed_random(genome, length = 100, n = 1e5, seed = 42) %>% 
  count(chrom, sort = TRUE)

#Random intervals

random_ivls <- bed_random(genome, length = 100, n = 1e5, seed = 42)

#Shuffle the random intervals generated above using `bed_shuffle()`
#chr1 now has 8037 intervals

bed_shuffle(random_ivls, genome, seed = 42) %>% 
  count(chrom)

#Shuffle the random intervals generated above using `bed_shuffle()`, but set `within` = TRUE
#chr1 has 7991 intervals, similar to using `bed_random()`

bed_shuffle(random_ivls, genome, seed = 42, within = TRUE) %>% 
  count(chrom)

```

Using `bed_random()` to generate 100,000 random intervals of 100 bp each, chromosome 1 (`chr1`) had the most intervals with 7991. Using `bed_shuffle()` on the set of random intervals (`random_ivls`) generated by `bed_random()`, there are now 8037 intervals on `chr1`. `bed_shuffle()` is taking the `random_ivls` and shuffling their location across the genome while maintaing the length of each individual interval (in this case, each interval is 100 bp), which is why there are now more intervals randomly placed onto `chr1`. However, if we set the `within` argument of `bed_shuffle()` to `TRUE`, there will again be 7991 intervals distributed across `chr1` because the `within = TRUE` argument maintains the original chromosome distribution. Therefore, the original 7991 intervals generated across `chr1` using `bed_random()` will be shuffled within `chr1` using `bed_shuffle()` - the intervals are at new locations, but are confined to `chr1`.

# Question 2

 Write a function that computes the final tibble needed for plotting a metagene. Explain in your interpretation why writing a function is useful for this task.
 
 The function should take three arguments.
  - `genes_bed` is a bed tibble that contains positions of human genes. (`chrom`, `start`, `end`, `name`, `score`, `strand`)
  - `chipseq_bedgraph` is a bedgraph tibble (`chrom`, `start`, `end`, `value`) 
  - `genome_bed` is a genome tibble (`chrom`, `size`)
  
Run your function using the bed tibbles provided above as input arguments.

Your output tibble should look like this:

```r
#> # A tibble: 201 x 2
#>    .win_id total_coverage
#>      <int>          <dbl>
#>  1       1       46.97059
#>  2       2       56.48529
#>  3       3       47.42667
#>  4       4       53.97297
#>  5       5       48.36842
#>  6       6       56.05333
#>  7       7       47.08861
#>  8       8       55.15190
#>  9       9       47.33750
#> 10      10       55.94937
#> # ... with 191 more rows
```


## Strategy

```{r q2}

compute_metagene <- function(chipseq_bedgraph,
                                genes_bed,
                              genome_bed){
  output <- genes_bed %>% 
    filter(strand == "+") %>% 
    mutate(end = start + 1) %>% 
    bed_slop(genome_bed, both = 1000) %>% 
    bed_makewindows(genome_bed, win_size = 10) %>% 
    bed_map(., 
            chipseq_bedgraph,
            total_reads = sum(value)) %>% 
    group_by(.win_id) %>%
    summarize(total_coverage = mean(total_reads, na.rm = TRUE)) 
  output
}

compute_metagene(bg, genes, genome)

```

## Interpretation

The `compute_metagene()` function takes three arguments (`chipseq_bedgraph`, a bedgraph tibble; `genes_bed`, a bed tibble containing the positions of human genes; and `genome_bed`, a genome tibble). In this case, `compute_metagene()` first generates a set of transcription start sites (TSS) for each gene from the plus strand (`strand == "+"`) from the `genes_bed` tibble (using the `filter()` and `mutate()` calls). Next, `compute_metagene()` calls on the `bed_slop()` and `bed_makewindows()` functions to generate a set of interval windows surrounding each TSS. A coverage map is then computed for `chipseq_bedgraph` using `bed_map()`, and for each TSS interval all overlapping intervals in `chipseq_bedgraph` are identified (`group_by()`) and averaged together (`summarize`). Thus, the `compute_metagene()` function generates a metagene profile surrounding the TSS that summarizes the coverage of a Chip-Seq experiment across the genome.

The function `compute_metagene()` is useful as it reduces repeated code (per the **D**on't **R**epeat **Y**ourself guideline), and allows for easy editing. Writing a `compute_metagene()` function is particularly useful in the case of wanting to compare the metagene profiles of several different experiments. Instead of writing the above code for each experiment, one can simply run the `compute_metagene()` function with different `chipseq_bedgraph` inputs. And, if you decide that you want to or need to change some parameter for your metagene profile analysis, it is simple to change that parameter a single time within the `compute_metagene()` function, rather than changing it multiple times for each experiment.

# Question 3

Write a function that plots a metagene. The function should take one argument, the output from question 2, and produce a plot. Run the function on the output of question 2, and show your plot. 

Here's some pseudo-code to get you started. I've also included some code that fixes the x-axis. 

``` r
plot_metagene <- function(dat) {
  
  region_size <- 1000
  win_size <- 10

  x_labels <- seq(-region_size, region_size, by = win_size * 25)
  x_breaks <- seq(1, 201, by = 25)

  ggplot(..., aes(..., ...)) +
  ... +
  scale_x_continuous(labels = x_labels, breaks = x_breaks)  +
}

plot_metagene(metagene_data)
```

## Strategy

```{r q3}

plot_metagene <- function(dat) {
  
  region_size <- 1000
  win_size <- 10

  x_labels <- seq(-region_size, region_size, by = win_size * 25)
  x_breaks <- seq(1, 201, by = 25)

  ggplot(dat, aes(.win_id, total_coverage)) +
  geom_point() +
  scale_x_continuous(labels = x_labels, breaks = x_breaks) +
  labs(title = "Metagene across all human Transcription Start Sites (TSS)",
      x = "Nucleotides from TSS",
      y = "Mean Coverage (RPM)")
}

metagene_data <- compute_metagene(bg, genes, genome)

plot_metagene(metagene_data)

```

## Interpretation

This plot illustrates the metagene profile of protein coverage (from a Chip-Seq experiment) surrounding the transcription start site, +/- 1000 nucleotides. The peak coverage is found on either side of the TSS, with the larger peak found downstream of the TSS. This indicates that the protein doesn't bind to the TSS. In this example, `chipseq_bedgraph` comes from an **h3k4** (methylation of lysine (**K**) **4** of **h**istone **3**) Chip-Seq experiment. Therefore, the sites of histone methylation are primarily found downstream of the TSS, with some histone methylations sites also found upstream of TSS. It was previously thought that the TSS was positioned within a "naked" DNA region, but recent studies have shown that the TSS is not histone-free and is instead associated with an unstable and nuclease-sensitive nucleosome. Additionally, genome-wide mapping of nucleosomes revealed that an active TSS is often followed by a strongly positioned '+1' nucleosome immediately downstream of the TSS, which might be illustrated by the strong peak in this plot.

Reference: [Histone variants at the transcription start-site](http://www.cell.com/trends/genetics/fulltext/S0168-9525(14)00051-1)

# Question 4

Use the `brauer_gene_exp` table to answer the following questions.

+ Are there any rows with `NA` values in `brauer_gene_exp`? Show your work. Hint: calculate the number of rows before and after removing `NA` values.

+ Which `systematic_name` and `nutrient` combination has the highest expression value? Interpret this result in the section below, keeping in mind that the `nutrient` condition indicates when the nutrient is *omitted* from the growth medium. Look up this gene at the [Saccharomyces Genome Database](http://yeastgenome.org).

## Strategy

```{r q4}

#converting blank variables to 'NA'
brauer_gene_exp[brauer_gene_exp == ""] <- NA

#Total number of rows in brauer_gene_exp, before removing 'NA' values (198430)
total_rows <- nrow(brauer_gene_exp)

#After removing 'NA' values (150865)
remove_na <- brauer_gene_exp %>% 
  na.omit(.) %>% 
  nrow(.)

#How many rows containted 'NA' values? (47565)
total_na = total_rows - remove_na

total_na

#Which 'systematic_name' and 'nutrient' combination has the highest expression value?
name_nutrient <- brauer_gene_exp %>%
  group_by(systematic_name, nutrient) %>%
  summarise(exp_mean = mean(expression)) %>% 
  arrange(desc(exp_mean))

head(name_nutrient,1)

```

## Interpretation

The `brauer_gene_exp` data set contains `r total_na` rows with `NA` values, out of a total of `r total_rows` rows.

**YJR152W** (also known as **DAL5**) is an allantoate transmembrane and dipeptide transporter that localizes to the plasma membrane. Allantoin is used a secondary source of nitrogen under nutrient-limiting conditions, and its degradation yields ammonia, which can then be utilized by the yeast. In this data set, the `nutrient` condition indicates what nutrinet is omitted from the growth medium. In this example, **ammonia** has been omitted from the growth medium. Since **ammonia** has been omitted, it makes sense that **YJR152W** would be upregulated, as the yeast would need some way to generate ammonia from its nutrient-limiting conditions.